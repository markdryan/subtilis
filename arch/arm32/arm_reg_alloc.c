/*
 * Copyright (c) 2017 Mark Ryan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "arm_int_dist.h"
#include "arm_reg_alloc.h"
#include "arm_sub_section.h"

/*
 * This needs some explanation as I keep forgetting how it works.
 *
 * The code generator spits out one section of ARM code for each
 * function and procedure including the main procedure.  This code
 * references registers.  Some of these registers, notably R13, are
 * fixed at code generation time.  The majority are not however.
 * Unfixed registers are described as floating.  There's an infinite
 * number of floating registers but a fixed number of ARM registers.
 * The register allocator's job is to replace each floating register
 * with a fixed register and ensure each fixed register contains the
 * correct value when it is used as a source operand.  Floating and
 * fixed registers can be distinguished by their number.  Any integer
 * register greater than 15 is a floating register.  Any FPA register
 * greater than 7 is also a floating register.
 *
 * The register allocator places a restriction on the code generator.
 *
 * 1. It assumes that no instruction uses the same floating point
 *    register for a source and a destination.  The IR generated by
 *    the parser should never do this.
 *
 * The register allocator is called once per section.  It begins by
 * identifying the basic blocks, or subsections, within each section.
 * Each subsection is delimited by branches and branch targets.  It
 * then figures out which virtual registers have lifetimes beyond a
 * single basic block and it ensures that their values are correctly
 * transferred between the basic blocks.  It does this by storing their
 * values on the stack before each branch and loading them from the stack
 * at the start of each new basic block.  Care is taken to only store
 * and load the registers that really needed to be persisted and
 * restored during a branch.  These values are stored and reloaded
 * by adding store and load instructions to the code.  Once this
 * has been done we can start allocating registers.  Note this is only
 * done for virtual registers.  Fixed registers are not saved and
 * restored across basic block boundaries.  They should need to be
 * and also this is currently not possible, as there are basic blocks
 * in the preamble before R11 is initialised.
 *
 * We are currently using a local register allocator.  It operates on
 * the entire section, treating it as a single basic block.  It can do
 * this as we have already instrumented the code to ensure that the
 * values of the virtual registers flow correctly across basic blocks.
 * It iterates through each instruction replacing floating source and
 * destination registers with fixed registers.  For each source register,
 * we call subtilis_arm_reg_alloc_ensure.  For floating registers,
 * subtilis_arm_reg_alloc_ensure, checks to see if the floating register has
 * already been assigned a fixed register. If it has we just need to update the
 * operand to refer to the fixed register.  If it hasn't we need to allocate a
 * new fixed register to represent that floating register for the time being. We
 * know that the floating register must have already been allocated earlier in
 * the function, otherwise it could not be used as an operand.  The
 * fact that it is not currently associated with a fixed register means
 * that it must have been spilled to the stack, by an allocation for
 * another register.  We now need to find a new fixed register for the
 * virtual register and load the spilled value into this register.  The
 * same process must be followed when ensuring fixed registers.  We need
 * to check if that register is mapped and if it isn't we need to spill
 * its current contents and load its own value from the stack.
 *
 * Allocation is done via subtilis_arm_reg_alloc_alloc.  Allocation for fixed
 * registers is simple.  We just need to spill the current value assigned to the
 * register and it's ours.  Allocating a floating register is more
 * complex.  We need to first check to see whether any physical registers
 * are available or not.  If one is available we assign it to our floating
 * register and our job is done.  If none are available we need to select
 * one of the already allocated physical registers, spill its current
 * contents and claim it.
 *
 * When we are processing the destination registers of an instruction
 * we only need to call subtilis_arm_reg_alloc_alloc and not
 * subtilis_arm_reg_alloc_ensure.  The reason is that we're replacing the value
 * in the virtual register and so it will no longer be used.  We don't need to
 * load its spilled value from the stack, as it's not needed and shouldn't be
 * there anyway.
 *
 * How do we know which is the best physical register to spill when all
 * physical registers are claimed and we need to allocate a new floating
 * register?  This, unfortunately, is the tricky piece and is intractable
 * in the general case.  This register allocator uses a simple heuristic.
 * Each time the allocator processes an instruction it computes a value
 * called a distance for each physical register used by the instruction.  The
 * distance is an absolute offset from the start of the section and it
 * indicates when the register is next used as a source operand.  If the
 * register is never read from again, its distance is set to -1.  The
 * next array of each register class stores the distances.  So when we need
 * to find a physical register for a floating register and all the physical
 * registers are already taken, we look through the next array of the
 * appropriate register class and choose the register that has the largest
 * distance, i.e., the one furthest away from the current instruction.
 * We also use the distance calculation to determine when registers are no
 * longer needed.  After a physical register has been used by an instruction
 * it can be returned to the pool of free physical registers if its distance
 * is -1.  We do this for both source and destination registers although
 * strictly speaking the code generator shouldn't be assigning values to
 * registers that are not then used ( although currently it does ).
 *
 * There's one subtelty here and that's one instruction, SWI, implicitly uses
 * registers.  When the code generator generates a specific SWI instruction
 * it needs to note which registers will be used by the instruction.  This
 * information is discarded by the encoder.
 *
 * Finally, the register allocator plays an important part in parameter passing.
 * If a function has more than four parameters of a given type, the 5th and
 * subsequent parameters of that type cannot be passed by register.  Instead
 * they are passed on the stack.   When the callee needs those parameters it
 * needs to load them from the stack into a register, much the same way as the
 * register allocator loads a spilled value from the stack into a register when
 * needed.  It is for this reason parameter passing is implemented with help
 * from the register allocator.  We simply push the 5th and subsequent
 * parameters on the stack before calling the function and then prime the
 * register allocators spill_stack with offsets to the values before we invoke
 * it.  It will then happily pop those values off the stack for us when they are
 * needed.
 */

/*
 * The other thing that needs documenting is the layout of the stack.  It should
 * look something like this.
 *
 * |------------------|     -------------------------------------------
 * |   int save 1     |     Callee saved integer registers.  This section
 * |------------------|     is mandatory and always contains at least one
 * |   int save n     |     register, R14
 * |----------------- |     -------------------------------------------
 * |   real save 1    |     Callee saved real registers.  This section
 * |                  |     optional and only exists if the callee
 * |----------------- |     uses real virtual registers that need to be
 * |   real save n    |     preserved across a procuedure call.
 * |                  |
 * |------------------|
 * |   return value   |
 * |----------------- |     -------------------------------------------
 * |   real arg n     |     This section is optional and only exists
 * |                  |     if there are more than 4 real arguments.
 * |------------------|     Arguments are pushed in reverse order.
 * |   real arg n-1   |     Each argument consumes 8 bytes.
 * |                  |
 * |----------------- |
 * |   real arg 4     |
 * |                  |
 * |------------------|     -------------------------------------------
 * |   int arg n      |     This section is optional and only exists
 * |------------------|     if there are more than 4 integer arguments.
 * |   int arg n-1    |     Arguments are pushed in reverse order.
 * |----------------- |     Each argument consumes 4 bytes.
 * |   int arg 4      |
 * |----------------- |     -------------------------------------------
 * |  spilt int reg 1 |     This section is optional and exists if the
 * |----------------- |     register allocator needed to spill any
 * |  spilt int reg n |     virtual integer registers. 4 bytes per reg.
 * |----------------- |     -------------------------------------------
 * | spilt real reg 1 |     This section is optional and exists if the
 * |                  |     register allocator needed to spill any
 * |----------------- |     virtual real registers.  Each spilt
 * | spilt real reg n |     register consumes 8 bytes.
 * |                  |
 * |----------------- |     -------------------------------------------
 * | prespilt real    |     This section is optional and exists if the
 * | reg1             |     register allocator needed to spill any
 * |----------------- |     virtual real registers at the end of a
 * | prespilt real    |     basic block.  Each spilt register consumes
 * | reg n            |     8 bytes.
 * |----------------- |     -------------------------------------------
 * | prespilt int reg1|     This section is optional and exists if the
 * |----------------- |     register allocator needed to spill any
 * | prespilt int reg2|     virtual int registers at the end of a
 * |----------------- |     basic block.  Each spilt register consumes
 * | prespilt int regn|     4 bytes
 * |----------------- |     -------------------------------------------
 * |                  |     Area reserved for storing local data, i.e.,
 * |                  |     local variables that are too large to fit
 * |  Local data      |     into a virtual register e.g., a string or
 * |                  |     an array.
 * |                  |
 * |----------------- |     -------------------------------------------  <- R11
 *
 * On entry to a function or procedure R11 and R13 point to the bottom
 * of the stack frame.  R13 may change during the lifetime of the function
 * call if stack space is needed for temporary storage, e.g., for calling
 * SWIs, or local heap objects are placed on the cleanup stack.
 */

/*
 * And finally, some words on how registers are preserved across function
 * and procedure calls.  Subtilis uses a caller save model, in which the
 * caller is responsible for saving and restoring any registers it needs
 * before and after a procedure call, regardless whether that call
 * actually corrupts those registers.  We could easily implement this
 * strategy in the pre-register allocation phase by having the BL instruction
 * trigger the end of a basic block.  All virtual registers used before and
 * after this instruction would be saved and restored for us using the
 * existing code.  However, I've decided not to do this for the time being as
 *
 * 1. It would be difficult to use stm and ldm.
 * 2. We'd need extra code to handle R11 and R14.  These aren't virtual
 *    registers so the basic block spill code can't account for them.
 *
 * Consequently, saving and preseving of registers before and after procedure
 * calls is done by a separate step after register allocation has been
 * completed.  It's a bit tricky as you have to work out which registers need to
 * be saved and restored and then update the offsets of any arguments passed via
 * the stack to reflect these values.  It all works out nicely in the end
 * though.
 *
 */

/*
 * The register allocator ignores MOV PC, *, which you would expect would
 * affect the distance calculations.  However, the front end will ensure
 * that this statement always comes at the end of a basic block so we can
 * safely ignore it.  In addition the code for computing the registers that
 * need to be saved across function calls treats everything that comes
 * before (and after) the function call as a basic block, which of course
 * it isn't.  Therefore we can't use MOV PC, * to affect the registers to
 * save calculation.
 */

struct subtilis_arm_prespilt_offsets_t_ {
	size_t *int_offsets;
	size_t *real_offsets;
	size_t int_count;
	size_t real_count;
};

typedef struct subtilis_arm_prespilt_offsets_t_ subtilis_arm_prespilt_offsets_t;

static void prv_arm_prespilt_offsets_init(subtilis_arm_prespilt_offsets_t *off)
{
	off->int_offsets = NULL;
	off->real_offsets = NULL;
	off->int_count = 0;
	off->real_count = 0;
}

static void prv_arm_prespilt_free(subtilis_arm_prespilt_offsets_t *off)
{
	free(off->int_offsets);
	free(off->real_offsets);
}

static void prv_arm_prespilt_calculate(subtilis_arm_prespilt_offsets_t *off,
				       subtilis_bitset_t *int_save,
				       subtilis_bitset_t *real_save,
				       subtilis_error_t *err)
{
	off->int_offsets =
	    subtilis_bitset_values(int_save, &off->int_count, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	off->real_offsets =
	    subtilis_bitset_values(real_save, &off->real_count, err);
}

static size_t prv_arm_presplit_int_offset(subtilis_arm_prespilt_offsets_t *off,
					  size_t reg, subtilis_error_t *err)
{
	size_t i;

	for (i = 0; i < off->int_count; i++)
		if (off->int_offsets[i] == reg)
			return i * sizeof(int32_t);

	subtilis_error_set_assertion_failed(err);

	return 0;
}

static size_t prv_arm_presplit_real_offset(subtilis_arm_prespilt_offsets_t *off,
					   size_t reg, subtilis_error_t *err)
{
	size_t i;
	size_t offset = off->int_count * sizeof(int32_t);

	for (i = 0; i < off->real_count; i++)
		if (off->real_offsets[i] == reg)
			return offset + (i * sizeof(double));

	subtilis_error_set_assertion_failed(err);

	return 0;
}

void subtilis_regs_used_virt_init(subtilis_regs_used_virt_t *regs_usedv)
{
	subtilis_bitset_init(&regs_usedv->int_regs);
	subtilis_bitset_init(&regs_usedv->real_regs);
}

void subtilis_regs_used_virt_free(subtilis_regs_used_virt_t *regs_usedv)
{
	subtilis_bitset_free(&regs_usedv->int_regs);
	subtilis_bitset_free(&regs_usedv->real_regs);
}

/* clang-format off */
static subtilis_arm_reg_class_t *prv_new_regs(
	size_t reg_count, size_t max_regs, size_t reg_start, size_t reg_size,
	size_t args, int32_t max_offset, subtilis_arm_reg_spill_imm_t spill_imm,
	subtilis_arm_reg_stran_imm_t stran_imm,
	subtilis_arm_instr_type_t store_type,
	subtilis_arm_instr_type_t load_type,
	subtilis_arm_fp_is_fixed_t is_fixed, subtilis_error_t *err)

/* clang-format on */
{
	size_t i;
	size_t index;
	subtilis_arm_reg_class_t *regs;
	size_t reg_args = 4;

	regs = calloc(sizeof(*regs), 1);
	if (!regs) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	regs->phys_to_virt = malloc(sizeof(*regs->phys_to_virt) * max_regs);
	if (!regs->phys_to_virt) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	regs->next = malloc(sizeof(*regs->next) * max_regs);
	if (!regs->next) {
		subtilis_error_set_oom(err);
		goto on_error;
	}

	if (args <= reg_args) {
		reg_args = args;
		regs->spill_top = 0;
	} else {
		regs->spill_top = args - reg_args;
	}

	regs->spilt_regs = malloc(reg_count * sizeof(int32_t));
	if (!regs->spilt_regs) {
		subtilis_error_set_oom(err);
		goto on_error;
	}
	regs->spill_stack = malloc(reg_count * sizeof(size_t));
	if (!regs->spill_stack) {
		subtilis_error_set_oom(err);
		goto on_error;
	}
	regs->max_regs = max_regs;
	regs->spill_max = regs->spill_top;
	regs->reg_size = reg_size;
	regs->spill_imm = spill_imm;
	regs->stran_imm = stran_imm;
	regs->store_type = store_type;
	regs->load_type = load_type;
	regs->max_offset = max_offset;
	regs->is_fixed = is_fixed;

	for (i = 0; i < reg_count; i++) {
		regs->spilt_regs[i] = -1;
		regs->spill_stack[i] = i * reg_size;
	}
	regs->vr_reg_count = reg_count;

	for (i = 0; i < reg_args; i++) {
		regs->next[i] = -1;
		regs->phys_to_virt[i] = i + reg_start;
	}

	for (; i < max_regs; i++) {
		regs->next[i] = -1;
		regs->phys_to_virt[i] = INT_MAX;
	}

	for (i = reg_args; i < args; i++) {
		index = i - reg_args;
		regs->spilt_regs[i + reg_start] = index * reg_size;
	}

	if (i > reg_args) {
		regs->spilt_args = i - reg_args;
		regs->spill_top = regs->spilt_args;
		regs->spill_max = regs->spill_top;
		for (i = 0; i < regs->spilt_args; i++)
			regs->spill_stack[i] = INT_MAX;
	} else {
		regs->spilt_args = 0;
	}

	regs->spill_points = NULL;
	regs->spill_points_count = 0;
	regs->spill_points_max = 0;

	return regs;

on_error:

	free(regs->spilt_regs);
	free(regs->next);
	free(regs->phys_to_virt);
	free(regs);

	return NULL;
}

static void prv_check_current_ss(subtilis_arm_reg_ud_t *ud,
				 subtilis_arm_op_t *op, subtilis_error_t *err)
{
	if (op != ud->ss_terminators[ud->current_ss])
		return;

	if (ud->current_ss == ud->max_ss) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	ud->current_ss++;
}

static void prv_free_regs(subtilis_arm_reg_class_t *regs)
{
	if (regs) {
		free(regs->spill_points);
		free(regs->spill_stack);
		free(regs->spilt_regs);
		free(regs->next);
		free(regs->phys_to_virt);
		free(regs);
	}
}

static void prv_add_spill_point(subtilis_arm_reg_class_t *regs,
				subtilis_spill_point_type_t type, size_t pos,
				int32_t offset, subtilis_arm_reg_t phys,
				subtilis_error_t *err)
{
	subtilis_spill_point_t *sp;
	size_t new_max;

	if (regs->spill_points_count == regs->spill_points_max) {
		new_max = regs->spill_points_count + SUBTILIS_CONFIG_SSS_GRAN;
		sp = realloc(regs->spill_points, new_max * sizeof(*sp));
		if (!sp) {
			subtilis_error_set_oom(err);
			return;
		}
		regs->spill_points = sp;
		regs->spill_points_max = new_max;
	}
	sp = &regs->spill_points[regs->spill_points_count++];
	sp->type = type;
	sp->pos = pos;
	sp->offset = offset;
	sp->phys = phys;
}

static void prv_init_arm_reg_ud(subtilis_arm_reg_ud_t *ud,
				subtilis_arm_section_t *arm_s,
				subtilis_error_t *err)
{
	size_t max_int_regs;
	size_t max_real_regs;

	subtilis_arm_section_max_regs(arm_s, &max_int_regs, &max_real_regs);

	if (!arm_s->fp_if) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	ud->int_regs = prv_new_regs(
	    max_int_regs, SUBTILIS_ARM_REG_MAX_INT_REGS,
	    SUBTILIS_ARM_INT_VIRT_REG_START, sizeof(int32_t),
	    arm_s->stype->int_regs, 4095, subtilis_arm_insert_stran_spill_imm,
	    subtilis_arm_insert_stran_imm, SUBTILIS_ARM_INSTR_STR,
	    SUBTILIS_ARM_INSTR_LDR, subtilis_arm_is_fixed, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->real_regs = prv_new_regs(
	    max_real_regs, arm_s->fp_if->max_regs, arm_s->fp_if->max_regs,
	    sizeof(double), arm_s->stype->fp_regs, arm_s->fp_if->max_offset,
	    arm_s->fp_if->spill_imm_fn, arm_s->fp_if->stran_imm_fn,
	    arm_s->fp_if->store_type, arm_s->fp_if->load_type,
	    arm_s->fp_if->is_fixed_fn, err);
	if (err->type != SUBTILIS_ERROR_OK) {
		prv_free_regs(ud->int_regs);
		return;
	}

	ud->instr_count = 0;
	ud->arm_s = arm_s;
	ud->ss_terminators = NULL;
	ud->current_ss = 0;
	ud->max_ss = 0;

	subtilis_init_int_dist_walker(&ud->int_regs->dist_walker,
				      &ud->dist_data);
	arm_s->fp_if->init_dist_walker_fn(&ud->real_regs->dist_walker,
					  &ud->dist_data);
	subtilis_init_int_used_walker(&ud->int_regs->used_walker,
				      &ud->dist_data);
	arm_s->fp_if->init_used_walker_fn(&ud->real_regs->used_walker,
					  &ud->dist_data);
}

int subtilis_arm_reg_alloc_calculate_dist(subtilis_arm_reg_ud_t *ud,
					  size_t reg_num, subtilis_arm_op_t *op,
					  subtlis_arm_walker_t *walker,
					  subtilis_arm_reg_class_t *regs)
{
	subtilis_error_t err;
	subtilis_arm_op_t *to;

	subtilis_error_init(&err);

	if (op->next == SIZE_MAX)
		return -1;

	op = &ud->arm_s->op_pool->ops[op->next];

	/*
	 * If we're calculating the distance for a virtual register
	 * we only need to go to the end of the basic block and not
	 * to the end of the function.  For fixed registers we need
	 * to go to the end of the function as these registers aren't
	 * currently preserved and restored as we move between basic
	 * blocks, although perhaps they should be.
	 */

	if (ud->ss_terminators && !regs->is_fixed(reg_num))
		to = ud->ss_terminators[ud->current_ss];
	else
		to = NULL;
	ud->dist_data.reg_num = reg_num;
	ud->dist_data.last_used = ud->instr_count + 1;

	subtilis_arm_walk_from_to(ud->arm_s, walker, op, to, &err);
	if (err.type != SUBTILIS_ERROR_OK)
		return ud->dist_data.last_used;
	else
		return -1;
}

static void prv_free_arm_reg_ud(subtilis_arm_reg_ud_t *ud)
{
	if (!ud)
		return;

	prv_free_regs(ud->real_regs);
	prv_free_regs(ud->int_regs);
	free(ud->ss_terminators);
}

static size_t prv_virt_to_phys(subtilis_arm_reg_class_t *regs,
			       subtilis_arm_reg_t *reg)
{
	size_t i;
	size_t retval = INT_MAX;

	for (i = 0; i < regs->max_regs; i++) {
		if (regs->phys_to_virt[i] == *reg)
			return i;
	}

	return retval;
}

static void prv_insert_spill_code_load(subtilis_arm_section_t *arm_s,
				       subtilis_arm_reg_t reg,
				       subtilis_arm_op_t *current,
				       subtilis_arm_reg_class_t *regs,
				       int32_t offset, subtilis_error_t *err)
{
	if (offset > regs->max_offset || offset < -regs->max_offset)
		regs->spill_imm(arm_s, current, regs->load_type,
				SUBTILIS_ARM_CCODE_AL, reg, 11, reg, offset,
				err);
	else
		regs->stran_imm(arm_s, current, regs->load_type,
				SUBTILIS_ARM_CCODE_AL, reg, 11, offset, err);
}

static void prv_insert_spill_code_store(subtilis_arm_section_t *arm_s,
					subtilis_arm_reg_t reg,
					subtilis_arm_op_t *current,
					subtilis_arm_reg_class_t *int_regs,
					subtilis_arm_reg_class_t *regs,
					int32_t offset, subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_t spill_reg;

	if (offset > regs->max_offset || offset < -regs->max_offset) {
		/*
		 * We need to find an integer register to act as our base
		 * when spilling the contents of reg_num.  So if we're
		 * currently spilling the contents of a floating point
		 * register we still need to use the int_regs structure
		 * to use as our base.
		 */

		for (i = 0; i < int_regs->max_regs; i++)
			if ((int_regs->phys_to_virt[i] == INT_MAX) &&
			    (int_regs != regs || i != reg))
				break;

		if (i == int_regs->max_regs) {
			/*
			 * TODO: Don't think this code has ever been tested.
			 */

			subtilis_arm_insert_push(arm_s, current,
						 SUBTILIS_ARM_CCODE_AL, 0, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			spill_reg = 0;
		} else {
			spill_reg = i;
		}
		regs->spill_imm(arm_s, current, regs->store_type,
				SUBTILIS_ARM_CCODE_AL, reg, 11, spill_reg,
				offset, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		if (i == int_regs->max_regs) {
			subtilis_arm_insert_pop(arm_s, current,
						SUBTILIS_ARM_CCODE_AL, 0, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	} else {
		regs->stran_imm(arm_s, current, regs->store_type,
				SUBTILIS_ARM_CCODE_AL, reg, 11, offset, err);
	}
}

static void prv_insert_spill_code(subtilis_arm_reg_ud_t *ud,
				  subtilis_arm_reg_class_t *regs,
				  int32_t offset, int32_t arg_offset,
				  subtilis_error_t *err)
{
	size_t i;
	subtilis_spill_point_t *sp;
	subtilis_arm_op_t *current;
	int32_t basic_offset;
	subtilis_arm_section_t *arm_s = ud->arm_s;

	for (i = 0; i < regs->spill_points_count; i++) {
		sp = &regs->spill_points[i];
		current = &arm_s->op_pool->ops[sp->pos];
		if (sp->offset < regs->spilt_args * regs->reg_size)
			basic_offset = arg_offset;
		else
			basic_offset = offset;
		basic_offset += sp->offset;
		if (sp->type == SUBTILIS_SPILL_POINT_LOAD) {
			prv_insert_spill_code_load(arm_s, sp->phys, current,
						   regs, basic_offset, err);
		} else {
			prv_insert_spill_code_store(arm_s, sp->phys, current,
						    ud->int_regs, regs,
						    basic_offset, err);
		}
	}
}

static void prv_load_spilled_reg(subtilis_arm_reg_ud_t *ud,
				 subtilis_arm_op_t *current,
				 subtilis_arm_reg_class_t *regs,
				 subtilis_arm_reg_t virt,
				 subtilis_arm_reg_t phys, subtilis_error_t *err)
{
	int i;
	size_t pos;
	subtilis_arm_section_t *arm_s = ud->arm_s;
	int32_t basic_offset = regs->spilt_regs[virt];

	if (basic_offset == INT_MAX) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	if (regs->spill_top == 0) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	if (current->prev == SIZE_MAX)
		pos = arm_s->first_op;
	else
		pos = arm_s->op_pool->ops[current->prev].next;

	prv_add_spill_point(regs, SUBTILIS_SPILL_POINT_LOAD, pos, basic_offset,
			    phys, err);

	regs->phys_to_virt[phys] = virt;
	regs->spilt_regs[virt] = INT_MAX;
	i = basic_offset / regs->reg_size;
	regs->spill_stack[i] = basic_offset;
	if (i == regs->spill_top - 1) {
		regs->spill_top--;
		for (i = i - 1; i >= 0; i--) {
			if (regs->spill_stack[i] == INT_MAX)
				break;
			regs->spill_top--;
		}
	}
	regs->next[phys] = -1;
}

static void prv_spill_reg(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *current,
			  size_t assigned, subtilis_arm_reg_class_t *int_regs,
			  subtilis_arm_reg_class_t *regs,
			  subtilis_arm_reg_t reg, subtilis_error_t *err)
{
	size_t i;
	int32_t offset;
	size_t pos;
	subtilis_arm_section_t *arm_s = ud->arm_s;

	if (regs->spill_top == regs->vr_reg_count) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	for (i = 0; i < regs->spill_top; i++)
		if (regs->spill_stack[i] != INT_MAX)
			break;

	offset = (int32_t)regs->spill_stack[i];
	regs->spill_stack[i] = INT_MAX;
	if (i == regs->spill_top) {
		regs->spill_top++;
		if (regs->spill_max < regs->spill_top)
			regs->spill_max = regs->spill_top;
	}

	regs->spilt_regs[assigned] = offset;

	if (current->prev == SIZE_MAX)
		pos = arm_s->first_op;
	else
		pos = arm_s->op_pool->ops[current->prev].next;

	prv_add_spill_point(regs, SUBTILIS_SPILL_POINT_STORE, pos, offset, reg,
			    err);
}

static void prv_allocate_fixed(subtilis_arm_reg_ud_t *ud,
			       subtilis_arm_op_t *current,
			       subtilis_arm_reg_class_t *int_regs,
			       subtilis_arm_reg_class_t *regs,
			       subtilis_arm_reg_t *reg, subtilis_error_t *err)
{
	size_t assigned;

	assigned = regs->phys_to_virt[*reg];

	/*
	 * If the fixed register is already assigned to itself there's
	 * no need to spill it.
	 */

	if (assigned != INT_MAX && assigned != *reg) {
		prv_spill_reg(ud, current, assigned, int_regs, regs, *reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}

static void
prv_allocate_floating(subtilis_arm_reg_ud_t *ud, subtilis_arm_op_t *current,
		      subtilis_arm_reg_class_t *int_regs,
		      subtilis_arm_reg_class_t *regs, subtilis_arm_reg_t *reg,
		      subtilis_arm_reg_t restricted, subtilis_error_t *err)
{
	subtilis_arm_reg_t target_reg;
	int i;
	int next = regs->max_regs;
	int max_next = -1;

	/* Virtual register is not already assigned. */

	for (i = regs->max_regs - 1; i >= 0; i--)
		if ((regs->phys_to_virt[i] == INT_MAX) &&
		    (restricted == SIZE_MAX || restricted != i))
			break;

	if (i >= 0) {
		target_reg = (size_t)i;
	} else {
		/* No free physical regs.  Need to spill. */

		for (i = 0; i < regs->max_regs; i++)
			if ((regs->next[i] > max_next) &&
			    (restricted == SIZE_MAX || restricted != i)) {
				max_next = regs->next[i];
				next = i;
			}
		if (next == regs->max_regs) {
			subtilis_error_set_assertion_failed(err);
			return;
		}
		target_reg = next;
		prv_spill_reg(ud, current, regs->phys_to_virt[next], int_regs,
			      regs, target_reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	*reg = target_reg;
}

void subtilis_arm_reg_alloc_alloc(subtilis_arm_reg_ud_t *ud,
				  subtilis_arm_op_t *current,
				  subtilis_arm_reg_class_t *int_regs,
				  subtilis_arm_reg_class_t *regs,
				  subtilis_arm_reg_t *reg,
				  subtilis_arm_reg_t restricted,
				  subtilis_error_t *err)
{
	size_t assigned;
	size_t virt_num = *reg;

	if (regs->is_fixed(*reg)) {
		if (*reg >= regs->max_regs)
			return;
		prv_allocate_fixed(ud, current, int_regs, regs, reg, err);
	} else {
		assigned = prv_virt_to_phys(regs, reg);
		if (assigned != INT_MAX) {
			*reg = assigned;
		} else {
			prv_allocate_floating(ud, current, int_regs, regs, reg,
					      restricted, err);
		}
	}

	if (err->type != SUBTILIS_ERROR_OK)
		return;

	regs->phys_to_virt[*reg] = virt_num;
}

/* Returns true if register is of fixed use, e.g., R13. */

bool subtilis_arm_reg_alloc_ensure(subtilis_arm_reg_ud_t *ud,
				   subtilis_arm_op_t *current,
				   subtilis_arm_reg_class_t *int_regs,
				   subtilis_arm_reg_class_t *regs,
				   subtilis_arm_reg_t *reg,
				   subtilis_error_t *err)
{
	size_t assigned;
	subtilis_arm_reg_t target_reg;

	if (regs->is_fixed(*reg)) {
		/*
		 * Register has fixed use and is unavailable to user's code
		 * Physical register has already been allocated, e.g., r12, r13
		 */
		if (*reg >= regs->max_regs)
			return true;

		assigned = regs->phys_to_virt[*reg];
		if (assigned != *reg) {
			prv_allocate_fixed(ud, current, int_regs, regs, reg,
					   err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			prv_load_spilled_reg(ud, current, regs, *reg, *reg,
					     err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
		}
	} else {
		assigned = prv_virt_to_phys(regs, reg);
		if (assigned != INT_MAX) {
			*reg = assigned;
		} else {
			target_reg = *reg;
			prv_allocate_floating(ud, current, int_regs, regs,
					      &target_reg, SIZE_MAX, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			prv_load_spilled_reg(ud, current, regs, *reg,
					     target_reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return false;
			*reg = target_reg;
		}
	}

	return false;
}

static void prv_alloc_label(void *user_data, subtilis_arm_op_t *op,
			    size_t label, subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	prv_check_current_ss(ud, op, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

static subtilis_arm_reg_t *prv_ensure_op2_reg(subtilis_arm_reg_ud_t *ud,
					      subtilis_arm_op_t *op,
					      int *dist_op2,
					      subtilis_arm_reg_t *reg,
					      subtilis_error_t *err)
{
	size_t vreg_op2;
	bool fixed_reg;

	vreg_op2 = *reg;
	fixed_reg = subtilis_arm_reg_alloc_ensure(ud, op, ud->int_regs,
						  ud->int_regs, reg, err);
	if (fixed_reg || (err->type != SUBTILIS_ERROR_OK))
		return NULL;

	*dist_op2 = subtilis_arm_reg_alloc_calculate_dist(
	    ud, vreg_op2, op, &ud->int_regs->dist_walker, ud->int_regs);
	if (*dist_op2 == -1)
		ud->int_regs->phys_to_virt[*reg] = INT_MAX;

	return reg;
}

static subtilis_arm_reg_t *prv_ensure_op2(subtilis_arm_reg_ud_t *ud,
					  subtilis_arm_op_t *op,
					  subtilis_arm_op2_t *op2,
					  int *dist_op2, subtilis_error_t *err)
{
	if (op2->type == SUBTILIS_ARM_OP2_I32)
		return NULL;

	if (op2->type == SUBTILIS_ARM_OP2_REG)
		return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.reg, err);
	else if (op2->type == SUBTILIS_ARM_OP2_SHIFTED)
		return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.shift.reg,
					  err);

	return NULL;
}

static subtilis_arm_reg_t *prv_ensure_op2_shift_reg(subtilis_arm_reg_ud_t *ud,
						    subtilis_arm_op_t *op,
						    subtilis_arm_op2_t *op2,
						    int *dist_op2,
						    subtilis_error_t *err)
{
	if ((op2->type != SUBTILIS_ARM_OP2_SHIFTED) || !op2->op.shift.shift_reg)
		return NULL;

	return prv_ensure_op2_reg(ud, op, dist_op2, &op2->op.shift.shift.reg,
				  err);
}

static void prv_allocate_dest_restricted(subtilis_arm_reg_ud_t *ud,
					 subtilis_arm_op_t *op,
					 subtilis_arm_reg_t *dest,
					 subtilis_arm_reg_t restricted,
					 subtilis_error_t *err)
{
	int dist_dest;
	size_t vreg_dest = *dest;

	if ((ud->int_regs->is_fixed(vreg_dest)) &&
	    (vreg_dest >= SUBTILIS_ARM_REG_MAX_INT_REGS))
		return;

	subtilis_arm_reg_alloc_alloc(ud, op, ud->int_regs, ud->int_regs, dest,
				     restricted, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	dist_dest = subtilis_arm_reg_alloc_calculate_dist(
	    ud, vreg_dest, op, &ud->int_regs->dist_walker, ud->int_regs);
	if (dist_dest == -1)
		ud->int_regs->phys_to_virt[*dest] = INT_MAX;
	ud->int_regs->next[*dest] = dist_dest;
}

void subtilis_arm_reg_alloc_alloc_dest(subtilis_arm_reg_ud_t *ud,
				       subtilis_arm_op_t *op,
				       subtilis_arm_reg_t *dest,
				       subtilis_error_t *err)
{
	prv_allocate_dest_restricted(ud, op, dest, SIZE_MAX, err);
}

void subtilis_arm_reg_alloc_alloc_fp_dest(subtilis_arm_reg_ud_t *ud,
					  subtilis_arm_op_t *op,
					  subtilis_arm_reg_t *dest,
					  subtilis_error_t *err)
{
	int dist_dest;
	size_t vreg_dest = *dest;

	subtilis_arm_reg_alloc_alloc(ud, op, ud->int_regs, ud->real_regs, dest,
				     SIZE_MAX, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	dist_dest = subtilis_arm_reg_alloc_calculate_dist(
	    ud, vreg_dest, op, &ud->real_regs->dist_walker, ud->real_regs);
	if (dist_dest == -1)
		ud->real_regs->phys_to_virt[*dest] = INT_MAX;
	ud->real_regs->next[*dest] = dist_dest;
}

static void prv_alloc_mov_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_data_instr_t *instr,
				subtilis_error_t *err)
{
	int dist_op2_shift;
	subtilis_arm_reg_t *reg;
	subtilis_arm_reg_t *shift_reg;
	int dist_op2 = -1;
	subtilis_arm_reg_ud_t *ud = user_data;

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	/* Need to check for useless moves */

	if (reg && !shift_reg && ((type != SUBTILIS_ARM_INSTR_MOV) ||
				  (instr->dest != instr->op2.op.reg)))
		ud->int_regs->next[*reg] = dist_op2;

	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_data_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_data_instr_t *instr,
				 subtilis_error_t *err)
{
	int dist_op1;
	int dist_op2;
	int dist_op2_shift;
	size_t vreg_op1;
	bool fixed_reg_op1;
	subtilis_arm_reg_ud_t *ud = user_data;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_t *shift_reg = NULL;

	vreg_op1 = instr->op1;
	fixed_reg_op1 = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1) {
		dist_op1 = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_op1, op, &ud->int_regs->dist_walker, ud->int_regs);
		if (dist_op1 == -1)
			ud->int_regs->phys_to_virt[instr->op1] = INT_MAX;
	}

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1)
		ud->int_regs->next[instr->op1] = dist_op1;
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;
	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_mul_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_mul_instr_t *instr,
				subtilis_error_t *err)
{
	size_t vreg_rm;
	bool fixed_reg_rm;
	size_t vreg_rs;
	bool fixed_reg_rs;
	int dist_rm = -1;
	int dist_rs = -1;
	subtilis_arm_reg_ud_t *ud = user_data;

	vreg_rm = instr->rm;
	fixed_reg_rm = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->rm, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	vreg_rs = instr->rs;
	fixed_reg_rs = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->rs, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_rm) {
		dist_rm = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_rm, op, &ud->int_regs->dist_walker, ud->int_regs);
		if (dist_rm == -1)
			ud->int_regs->phys_to_virt[instr->rm] = INT_MAX;
	}

	if (!fixed_reg_rs) {
		dist_rs = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_rs, op, &ud->int_regs->dist_walker, ud->int_regs);
		if (dist_rs == -1)
			ud->int_regs->phys_to_virt[instr->rs] = INT_MAX;
	}

	prv_allocate_dest_restricted(ud, op, &instr->dest, instr->rm, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (instr->dest == instr->rm) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	if (!fixed_reg_rm)
		ud->int_regs->next[instr->rm] = dist_rm;
	if (!fixed_reg_rs)
		ud->int_regs->next[instr->rs] = dist_rs;

	ud->instr_count++;
}

static void prv_alloc_stran_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_stran_instr_t *instr,
				  subtilis_error_t *err)
{
	int dist_dest;
	int dist_op2;
	size_t vreg_dest;
	size_t vreg_base;
	bool fixed_reg_base;
	bool fixed_reg_dest = false;
	int dist_base = -1;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_ud_t *ud = user_data;

	if (type == SUBTILIS_ARM_INSTR_STR) {
		vreg_dest = instr->dest;
		fixed_reg_dest = subtilis_arm_reg_alloc_ensure(
		    ud, op, ud->int_regs, ud->int_regs, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	vreg_base = instr->base;
	fixed_reg_base = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->base, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->offset, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_base) {
		dist_base = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_base, op, &ud->int_regs->dist_walker,
		    ud->int_regs);
		if (dist_base == -1)
			ud->int_regs->phys_to_virt[instr->base] = INT_MAX;
	}

	if (type == SUBTILIS_ARM_INSTR_STR) {
		if (!fixed_reg_dest) {
			dist_dest = subtilis_arm_reg_alloc_calculate_dist(
			    ud, vreg_dest, op, &ud->int_regs->dist_walker,
			    ud->int_regs);
			if (dist_dest == -1)
				ud->int_regs->phys_to_virt[instr->dest] =
				    INT_MAX;
			ud->int_regs->next[instr->dest] = dist_dest;
		}
	} else {
		subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	if (!fixed_reg_base)
		ud->int_regs->next[instr->base] = dist_base;
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;

	ud->instr_count++;
}

static void prv_alloc_mtran_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_mtran_instr_t *instr,
				  subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	/*
	 * TODO: Again mtran is not currently been used as a general
	 * instruction.  We're just inserting it into the code after
	 * register allocation has happened to implement a stack.
	 */

	ud->instr_count++;
}

static void prv_alloc_br_instr(void *user_data, subtilis_arm_op_t *op,
			       subtilis_arm_instr_type_t type,
			       subtilis_arm_br_instr_t *instr,
			       subtilis_error_t *err)
{
	size_t vreg_op1;
	bool fixed_reg_op1 = true;
	int dist_op1;
	subtilis_arm_reg_ud_t *ud = user_data;
	size_t reg = 0;
	subtilis_arm_reg_class_t *regs = NULL;

	if (instr->indirect) {
		vreg_op1 = instr->target.reg;
		fixed_reg_op1 = subtilis_arm_reg_alloc_ensure(
		    ud, op, ud->int_regs, ud->int_regs, &instr->target.reg,
		    err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		if (!fixed_reg_op1) {
			dist_op1 = subtilis_arm_reg_alloc_calculate_dist(
			    ud, vreg_op1, op, &ud->int_regs->dist_walker,
			    ud->int_regs);
			if (dist_op1 == -1)
				ud->int_regs->phys_to_virt[instr->target.reg] =
				    INT_MAX;
		}
	}

	/*
	 * We need to make sure that F0 or R0 are marked as being
	 * allocated when we return from a function.  Otherwise we
	 * can get an assertion when we ensure them later in the code.
	 */

	if (instr->link_type == SUBTILIS_ARM_BR_LINK_INT)
		regs = ud->int_regs;
	else if (instr->link_type == SUBTILIS_ARM_BR_LINK_REAL)
		regs = ud->real_regs;

	if (regs) {
		subtilis_arm_reg_alloc_alloc(ud, op, ud->int_regs, regs, &reg,
					     SIZE_MAX, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	if (instr->indirect && !fixed_reg_op1)
		ud->int_regs->next[instr->target.reg] = dist_op1;

	ud->instr_count++;

	prv_check_current_ss(ud, op, err);
}

static void prv_alloc_swi_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_swi_instr_t *instr,
				subtilis_error_t *err)
{
	size_t i;
	int dist;
	subtilis_arm_reg_t reg;
	subtilis_arm_reg_ud_t *ud = user_data;

	/* SWIs can only use the first 10 regs */

	for (i = 0; i < 10; i++) {
		if ((1 << i) & instr->reg_read_mask) {
			reg = i;
			subtilis_arm_reg_alloc_ensure(ud, op, ud->int_regs,
						      ud->int_regs, &reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			dist = subtilis_arm_reg_alloc_calculate_dist(
			    ud, reg, op, &ud->int_regs->dist_walker,
			    ud->int_regs);
			if (dist == -1)
				ud->int_regs->phys_to_virt[reg] = INT_MAX;
			ud->int_regs->next[reg] = dist;
		} else if ((1 << i) & instr->reg_write_mask) {
			reg = i;
			subtilis_arm_reg_alloc_alloc_dest(ud, op, &reg, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	ud->instr_count++;
}

static void prv_alloc_ldrc_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_ldrc_instr_t *instr,
				 subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

static void prv_alloc_adr_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_adr_instr_t *instr,
				subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

static void prv_alloc_ldrp_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_ldrp_instr_t *instr,
				 subtilis_error_t *err)
{
	subtilis_arm_reg_ud_t *ud = user_data;

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	ud->instr_count++;
}

static void prv_alloc_cmov_instr(void *user_data, subtilis_arm_op_t *op,
				 subtilis_arm_instr_type_t type,
				 subtilis_arm_cmov_instr_t *instr,
				 subtilis_error_t *err)
{
	int dist_op[3];
	size_t vreg_op[3];
	bool fixed_reg_op[3];
	subtilis_arm_reg_t *reg_ptr[3];
	size_t i;
	subtilis_arm_reg_ud_t *ud = user_data;
	size_t count = 2;

	if (!instr->fused)
		count++;

	i = 0;

	if (!instr->fused) {
		vreg_op[i] = instr->op1;
		reg_ptr[i++] = &instr->op1;
	}
	vreg_op[i] = instr->op2;
	reg_ptr[i++] = &instr->op2;
	vreg_op[i] = instr->op3;
	reg_ptr[i] = &instr->op3;

	for (i = 0; i < count; i++) {
		fixed_reg_op[i] = subtilis_arm_reg_alloc_ensure(
		    ud, op, ud->int_regs, ud->int_regs, reg_ptr[i], err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	for (i = 0; i < count; i++) {
		if (!fixed_reg_op[i]) {
			dist_op[i] = subtilis_arm_reg_alloc_calculate_dist(
			    ud, vreg_op[i], op, &ud->int_regs->dist_walker,
			    ud->int_regs);
			if (dist_op[i] == -1)
				ud->int_regs->phys_to_virt[*reg_ptr[i]] =
				    INT_MAX;
		}
	}

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	for (i = 0; i < count; i++)
		if (!fixed_reg_op[i])
			ud->int_regs->next[*reg_ptr[i]] = dist_op[i];

	ud->instr_count++;
}

static void prv_alloc_cmp_instr(void *user_data, subtilis_arm_op_t *op,
				subtilis_arm_instr_type_t type,
				subtilis_arm_data_instr_t *instr,
				subtilis_error_t *err)
{
	int dist_op1;
	int dist_op2;
	int dist_op2_shift;
	size_t vreg_op1;
	bool fixed_reg_op1;
	subtilis_arm_reg_ud_t *ud = user_data;
	subtilis_arm_reg_t *reg = NULL;
	subtilis_arm_reg_t *shift_reg = NULL;

	vreg_op1 = instr->op1;
	fixed_reg_op1 = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	reg = prv_ensure_op2(ud, op, &instr->op2, &dist_op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	shift_reg =
	    prv_ensure_op2_shift_reg(ud, op, &instr->op2, &dist_op2_shift, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1) {
		dist_op1 = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_op1, op, &ud->int_regs->dist_walker, ud->int_regs);
		if (dist_op1 == -1)
			ud->int_regs->phys_to_virt[instr->op1] = INT_MAX;

		ud->int_regs->next[instr->op1] = dist_op1;
	}
	if (reg)
		ud->int_regs->next[*reg] = dist_op2;
	if (shift_reg)
		ud->int_regs->next[*shift_reg] = dist_op2_shift;

	ud->instr_count++;
}

static void prv_alloc_flags_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_flags_instr_t *instr,
				  subtilis_error_t *err)
{
	subtilis_arm_reg_t vreg;
	subtilis_arm_reg_ud_t *ud = user_data;
	bool fixed_reg;
	int dist;

	if (type == SUBTILIS_ARM_INSTR_MRS) {
		subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->op.reg, err);
	} else if (instr->flag_reg) {
		vreg = instr->op.reg;
		fixed_reg = subtilis_arm_reg_alloc_ensure(
		    ud, op, ud->int_regs, ud->int_regs, &instr->op.reg, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		if (!fixed_reg) {
			dist = subtilis_arm_reg_alloc_calculate_dist(
			    ud, vreg, op, &ud->int_regs->dist_walker,
			    ud->int_regs);
			if (dist == -1)
				ud->int_regs->phys_to_virt[instr->op.reg] =
				    INT_MAX;
			ud->int_regs->next[instr->op.reg] = dist;
		}
	}

	ud->instr_count++;
}

static void prv_alloc_signx_instr(void *user_data, subtilis_arm_op_t *op,
				  subtilis_arm_instr_type_t type,
				  subtilis_arm_signx_instr_t *instr,
				  subtilis_error_t *err)
{
	size_t vreg_op1;
	bool fixed_reg_op1;
	int dist_op1 = -1;
	subtilis_arm_reg_ud_t *ud = user_data;

	vreg_op1 = instr->op1;
	fixed_reg_op1 = subtilis_arm_reg_alloc_ensure(
	    ud, op, ud->int_regs, ud->int_regs, &instr->op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1) {
		dist_op1 = subtilis_arm_reg_alloc_calculate_dist(
		    ud, vreg_op1, op, &ud->int_regs->dist_walker, ud->int_regs);
		if (dist_op1 == -1)
			ud->int_regs->phys_to_virt[instr->op1] = INT_MAX;
	}

	subtilis_arm_reg_alloc_alloc_dest(ud, op, &instr->dest, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	if (!fixed_reg_op1)
		ud->int_regs->next[instr->op1] = dist_op1;

	ud->instr_count++;
}

static void prv_sub_section_int_links(subtilis_arm_reg_ud_t *ud,
				      subtilis_bitset_t *int_save,
				      subtilis_arm_ccode_type_t ccode,
				      subtilis_arm_prespilt_offsets_t *offsets,
				      subtilis_arm_op_t *op,
				      subtilis_error_t *err)
{
	int j;
	int32_t offset;
	subtilis_arm_reg_t reg;

	for (j = 0; j <= int_save->max_value; j++) {
		if (!subtilis_bitset_isset(int_save, j))
			continue;
		offset = prv_arm_presplit_int_offset(offsets, j, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		offset += ud->arm_s->locals;

		if (offset > 4095 || offset < -4095) {
			reg = subtilis_arm_acquire_new_reg(ud->arm_s);
			subtilis_arm_insert_stran_spill_imm(
			    ud->arm_s, op, SUBTILIS_ARM_INSTR_STR, ccode, j, 11,
			    reg, offset, err);
		} else {
			subtilis_arm_insert_stran_imm(
			    ud->arm_s, op, SUBTILIS_ARM_INSTR_STR, ccode, j, 11,
			    offset, err);
		}
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}

static void prv_sub_section_real_links(subtilis_arm_reg_ud_t *ud,
				       subtilis_bitset_t *real_save,
				       subtilis_arm_ccode_type_t ccode,
				       subtilis_arm_prespilt_offsets_t *offsets,
				       subtilis_arm_op_t *op,
				       subtilis_error_t *err)
{
	int j;
	int32_t offset;
	subtilis_arm_reg_t reg;

	for (j = 0; j <= real_save->max_value; j++) {
		if (!subtilis_bitset_isset(real_save, j))
			continue;
		offset = prv_arm_presplit_real_offset(offsets, j, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		offset += ud->arm_s->locals;

		if (offset > ud->arm_s->fp_if->max_offset ||
		    offset < -(ud->arm_s->fp_if->max_offset + 1)) {
			reg = subtilis_arm_acquire_new_reg(ud->arm_s);
			ud->arm_s->fp_if->spill_imm_fn(
			    ud->arm_s, op, ud->arm_s->fp_if->store_type, ccode,
			    j, 11, reg, offset, err);
		} else {
			ud->arm_s->fp_if->stran_imm_fn(
			    ud->arm_s, op, ud->arm_s->fp_if->store_type, ccode,
			    j, 11, offset, err);
		}
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}

static void prv_compute_save_sets(subtilis_bitset_t *old_link1_save,
				  subtilis_bitset_t *old_link2_save,
				  subtilis_bitset_t *common_save,
				  subtilis_bitset_t *link1_save,
				  subtilis_bitset_t *link2_save,
				  subtilis_error_t *err)
{
	subtilis_bitset_or(common_save, old_link1_save, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	subtilis_bitset_and(common_save, old_link2_save);

	subtilis_bitset_or(link1_save, old_link1_save, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	subtilis_bitset_or(link2_save, old_link2_save, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	subtilis_bitset_sub(link1_save, common_save);
	subtilis_bitset_sub(link2_save, common_save);
}

static void prv_init_two_links(subtilis_arm_reg_ud_t *ud, subtilis_arm_ss_t *ss,
			       subtilis_arm_prespilt_offsets_t *offsets,
			       size_t ss_index, subtilis_error_t *err)
{
	subtilis_arm_ss_link_t *link1;
	subtilis_arm_ss_link_t *link2;
	subtilis_arm_op_t *op1;
	subtilis_arm_op_t *op2;
	subtilis_arm_ccode_type_t ccode;
	subtilis_bitset_t common_save;
	subtilis_bitset_t link1_save;
	subtilis_bitset_t link2_save;

	subtilis_bitset_init(&common_save);
	subtilis_bitset_init(&link1_save);
	subtilis_bitset_init(&link2_save);

	link1 = &ss->links[0];
	link2 = &ss->links[1];
	op1 = &ud->arm_s->op_pool->ops[link1->op];
	op2 = &ud->arm_s->op_pool->ops[link2->op];
	ud->ss_terminators[ss_index] = op2;
	if ((op1->type != SUBTILIS_ARM_OP_INSTR) ||
	    (op1->op.instr.type != SUBTILIS_ARM_INSTR_B) ||
	    (op2->type != SUBTILIS_ARM_OP_LABEL)) {
		subtilis_error_set_assertion_failed(err);
		goto cleanup;
	}
	ccode = op1->op.instr.operands.br.ccode;

	prv_compute_save_sets(&link1->int_save, &link2->int_save, &common_save,
			      &link1_save, &link2_save, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_int_links(ud, &common_save, SUBTILIS_ARM_CCODE_AL,
				  offsets, op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_int_links(ud, &link1_save, ccode, offsets, op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_int_links(ud, &link2_save, SUBTILIS_ARM_CCODE_AL,
				  offsets, op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	subtilis_bitset_reset(&common_save);
	subtilis_bitset_reset(&link1_save);
	subtilis_bitset_reset(&link2_save);

	prv_compute_save_sets(&link1->real_save, &link2->real_save,
			      &common_save, &link1_save, &link2_save, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_real_links(ud, &common_save, SUBTILIS_ARM_CCODE_AL,
				   offsets, op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_real_links(ud, &link1_save, ccode, offsets, op1, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	prv_sub_section_real_links(ud, &link2_save, SUBTILIS_ARM_CCODE_AL,
				   offsets, op2, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

cleanup:

	subtilis_bitset_free(&link2_save);
	subtilis_bitset_free(&link1_save);
	subtilis_bitset_free(&common_save);
}

static void prv_init_sub_section_links(subtilis_arm_reg_ud_t *ud,
				       subtilis_arm_ss_t *ss,
				       subtilis_arm_prespilt_offsets_t *offsets,
				       size_t ss_index, subtilis_error_t *err)
{
	subtilis_arm_ss_link_t *link;
	subtilis_arm_op_t *op;
	subtilis_arm_ccode_type_t ccode;

	if (ss->num_links == 0)
		return;

	if (ss->num_links == 1) {
		link = &ss->links[0];
		op = &ud->arm_s->op_pool->ops[link->op];
		ud->ss_terminators[ss_index] = op;
		ccode = SUBTILIS_ARM_CCODE_AL;
		prv_sub_section_int_links(ud, &link->int_save, ccode, offsets,
					  op, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		prv_sub_section_real_links(ud, &link->real_save, ccode, offsets,
					   op, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		return;
	}

	if (ss->num_links != 2) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	prv_init_two_links(ud, ss, offsets, ss_index, err);
}

static void prv_init_sub_section(subtilis_arm_reg_ud_t *ud,
				 subtilis_arm_ss_t *ss,
				 subtilis_arm_prespilt_offsets_t *offsets,
				 subtilis_error_t *err)
{
	int i;
	int32_t offset;
	subtilis_arm_op_t *op;

	op = &ud->arm_s->op_pool->ops[ss->start];
	if (op->next == ud->arm_s->last_op)
		return;
	op = &ud->arm_s->op_pool->ops[op->next];

	for (i = 0; i <= ss->int_inputs.max_value; i++) {
		if (!subtilis_bitset_isset(&ss->int_inputs, i))
			continue;
		offset = prv_arm_presplit_int_offset(offsets, i, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		offset += ud->arm_s->locals;

		if (offset > 4095 || offset < -4095)
			subtilis_arm_insert_stran_spill_imm(
			    ud->arm_s, op, SUBTILIS_ARM_INSTR_LDR,
			    SUBTILIS_ARM_CCODE_AL, i, 11, i, offset, err);
		else
			subtilis_arm_insert_stran_imm(
			    ud->arm_s, op, SUBTILIS_ARM_INSTR_LDR,
			    SUBTILIS_ARM_CCODE_AL, i, 11, offset, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}

	for (i = 0; i <= ss->real_inputs.max_value; i++) {
		if (!subtilis_bitset_isset(&ss->real_inputs, i))
			continue;
		offset = prv_arm_presplit_real_offset(offsets, i, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
		offset += ud->arm_s->locals;

		if (offset > ud->arm_s->fp_if->max_offset ||
		    offset < -(ud->arm_s->fp_if->max_offset + 1))
			ud->arm_s->fp_if->spill_imm_fn(
			    ud->arm_s, op, ud->arm_s->fp_if->load_type,
			    SUBTILIS_ARM_CCODE_AL, i, 11, i, offset, err);
		else
			ud->arm_s->fp_if->stran_imm_fn(
			    ud->arm_s, op, ud->arm_s->fp_if->load_type,
			    SUBTILIS_ARM_CCODE_AL, i, 11, offset, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}

static void prv_link_basic_blocks(subtilis_arm_reg_ud_t *ud,
				  subtilis_error_t *err)
{
	subtilis_arm_subsections_t sss;
	subtilis_arm_prespilt_offsets_t offsets;
	size_t i;

	subtilis_arm_subsections_init(&sss);
	prv_arm_prespilt_offsets_init(&offsets);

	subtilis_arm_subsections_calculate(&sss, ud->arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	ud->max_ss = sss.count;
	ud->ss_terminators = calloc(sss.count, sizeof(*ud->ss_terminators));
	if (!ud->ss_terminators) {
		subtilis_error_set_oom(err);
		goto cleanup;
	}

	prv_arm_prespilt_calculate(&offsets, &sss.int_save, &sss.real_save,
				   err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	ud->basic_block_spill = (offsets.int_count * sizeof(int32_t)) +
				(offsets.real_count * sizeof(double));

	prv_init_sub_section_links(ud, &sss.sub_sections[0], &offsets, 0, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;
	for (i = 1; i < sss.count; i++) {
		prv_init_sub_section(ud, &sss.sub_sections[i], &offsets, err);
		if (err->type != SUBTILIS_ERROR_OK)
			goto cleanup;
		prv_init_sub_section_links(ud, &sss.sub_sections[i], &offsets,
					   i, err);
		if (err->type != SUBTILIS_ERROR_OK)
			goto cleanup;
	}

cleanup:

	prv_arm_prespilt_free(&offsets);
	subtilis_arm_subsections_free(&sss);
}

static void prv_alloc_directive(void *user_data, subtilis_arm_op_t *op,
				subtilis_error_t *err)
{
}

size_t subtilis_arm_reg_alloc(subtilis_arm_section_t *arm_s,
			      subtilis_error_t *err)
{
	subtlis_arm_walker_t walker;
	subtilis_arm_reg_ud_t ud;
	size_t retval;
	int32_t offset;
	int32_t adjusted_offset;
	int32_t arg_offset;
	int32_t int_spill_space;
	int32_t real_spill_space;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return 0;

	prv_link_basic_blocks(&ud, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return 0;

	walker.user_data = &ud;
	walker.label_fn = prv_alloc_label;
	walker.directive_fn = prv_alloc_directive;
	walker.data_fn = prv_alloc_data_instr;
	walker.mul_fn = prv_alloc_mul_instr;
	walker.cmp_fn = prv_alloc_cmp_instr;
	walker.mov_fn = prv_alloc_mov_instr;
	walker.stran_fn = prv_alloc_stran_instr;
	walker.mtran_fn = prv_alloc_mtran_instr;
	walker.br_fn = prv_alloc_br_instr;
	walker.swi_fn = prv_alloc_swi_instr;
	walker.ldrc_fn = prv_alloc_ldrc_instr;
	walker.ldrp_fn = prv_alloc_ldrp_instr;
	walker.adr_fn = prv_alloc_adr_instr;
	walker.cmov_fn = prv_alloc_cmov_instr;
	walker.flags_fn = prv_alloc_flags_instr;
	walker.stran_misc_fn = NULL;
	walker.simd_fn = NULL;
	walker.signx_fn = prv_alloc_signx_instr;
	arm_s->fp_if->init_real_alloc_fn(&walker, &ud);

	subtilis_arm_walk(arm_s, &walker, err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	/*
	 * See the description of the stack layout above to understand
	 * this code.  The register allocators assume they are sole
	 * onwers of the stack and that any arguments of their type
	 * are the first offsets spilled.  This assumption is invalid
	 * if more than one type of argument is passed on the stack or
	 * virtual registers of any type are actually spilled.  So we
	 * need to adjust the offsets of the spill code before we
	 * insert it.  There are two offsets one for spilled registers
	 * and one for spilled arguments.  The register allocators
	 * treat spilled arguments as being contiguous with their spilled
	 * registers but this is not necessarily the case, hence the
	 * two offsets.
	 */

	/*
	 * Note the space allocated to spill arguments by the register
	 * allocators won't actually be used as their values are stored
	 * further up the stack.
	 */

	int_spill_space = (ud.int_regs->spill_max - ud.int_regs->spilt_args) *
			  ud.int_regs->reg_size;

	real_spill_space =
	    (ud.real_regs->spill_max - ud.real_regs->spilt_args) *
	    ud.real_regs->reg_size;

	offset = ud.basic_block_spill + arm_s->locals;

	/*
	 * The register allocators assign offsets to spilled registers after
	 * they have assigned offsets to any arguments passed on the stack.
	 * However, such arguments are not in reality stored as part of the
	 * virtual registers spill space, so we need to subtract these
	 * arguments to correctly compute the adjusted offset.
	 */

	adjusted_offset =
	    offset - (ud.real_regs->spilt_args * ud.real_regs->reg_size);
	arg_offset = offset + real_spill_space + int_spill_space;
	prv_insert_spill_code(&ud, ud.real_regs, adjusted_offset, arg_offset,
			      err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	offset += real_spill_space;
	adjusted_offset =
	    offset - (ud.int_regs->spilt_args * ud.int_regs->reg_size);
	arg_offset += ud.real_regs->spilt_args * ud.real_regs->reg_size;
	prv_insert_spill_code(&ud, ud.int_regs, adjusted_offset, arg_offset,
			      err);
	if (err->type != SUBTILIS_ERROR_OK)
		goto cleanup;

	arm_s->reg_counter = 16;

	retval = (ud.int_regs->spill_max * sizeof(int32_t)) +
		 (ud.real_regs->spill_max * sizeof(double)) +
		 ud.basic_block_spill;

	prv_free_arm_reg_ud(&ud);

	return retval;

cleanup:

	prv_free_arm_reg_ud(&ud);

	return 0;
}

static bool prv_is_reg_used_before(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				   subtlis_arm_walker_t *used_walker,
				   subtilis_arm_op_t *from,
				   subtilis_arm_op_t *to)
{
	subtilis_error_t err;

	subtilis_error_init(&err);
	ud->dist_data.reg_num = reg_num;
	ud->dist_data.last_used = 0;
	subtilis_arm_walk_from_to(ud->arm_s, used_walker, from, to, &err);
	if ((err.type == SUBTILIS_ERROR_OK) || (ud->dist_data.last_used != -1))
		return false;

	return true;
}

void subtilis_arm_regs_used_before_from_tov(subtilis_arm_section_t *arm_s,
					    subtilis_arm_op_t *from,
					    subtilis_arm_op_t *op,
					    size_t int_args, size_t real_args,
					    subtilis_regs_used_virt_t *used,
					    subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	for (i = SUBTILIS_ARM_INT_VIRT_REG_START; i < int_args; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.int_regs->used_walker,
					   from, op)) {
			subtilis_bitset_set(&used->int_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	for (i = arm_s->fp_if->max_regs; i < real_args; i++) {
		if (prv_is_reg_used_before(&ud, i, &ud.real_regs->used_walker,
					   from, op)) {
			subtilis_bitset_set(&used->real_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	prv_free_arm_reg_ud(&ud);
}

static void prv_arm_regs_used_before_from_to(subtilis_arm_section_t *arm_s,
					     subtilis_arm_op_t *from,
					     subtilis_arm_op_t *op,
					     size_t int_args, size_t real_args,
					     subtilis_regs_used_t *regs_used,
					     subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;
	size_t int_reg_list = 0;
	size_t real_reg_list = 0;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	i = int_args;
	if (i > SUBTILIS_ARM_REG_MAX_ARGS)
		i = SUBTILIS_ARM_REG_MAX_ARGS;
	for (; i <= SUBTILIS_ARM_REG_MAX_INT_REGS - 1; i++) {
		if (i < arm_s->stype->int_regs ||
		    prv_is_reg_used_before(&ud, i, &ud.int_regs->used_walker,
					   from, op))
			int_reg_list |= 1 << i;
	}

	i = real_args;
	if (i > SUBTILIS_ARM_REG_MAX_ARGS)
		i = SUBTILIS_ARM_REG_MAX_ARGS;
	for (; i < arm_s->fp_if->max_regs; i++) {
		if (i < arm_s->stype->fp_regs ||
		    prv_is_reg_used_before(&ud, i, &ud.real_regs->used_walker,
					   from, op))
			real_reg_list |= 1 << i;
	}

	regs_used->int_regs = int_reg_list;
	regs_used->real_regs = real_reg_list;

	prv_free_arm_reg_ud(&ud);
}

void subtilis_arm_regs_used_before(subtilis_arm_section_t *arm_s,
				   subtilis_arm_op_t *op, size_t int_args,
				   size_t real_args,
				   subtilis_regs_used_t *regs_used,
				   subtilis_error_t *err)
{
	subtilis_arm_op_t *from;

	from = &arm_s->op_pool->ops[arm_s->first_op];
	prv_arm_regs_used_before_from_to(arm_s, from, op, int_args, real_args,
					 regs_used, err);
}

static bool prv_is_reg_used_after_to(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				     subtlis_arm_walker_t *dist_walker,
				     subtilis_arm_op_t *from,
				     subtilis_arm_op_t *to)
{
	subtilis_error_t err;

	subtilis_error_init(&err);

	ud->dist_data.reg_num = reg_num;
	ud->dist_data.last_used = ud->instr_count + 1;

	subtilis_arm_walk_from_to(ud->arm_s, dist_walker, from, to, &err);

	/*
	 * Check that reg_num is used and that the  first usage of
	 * reg_num is not a write.
	 */

	return (err.type != SUBTILIS_ERROR_OK) &&
	       (ud->dist_data.last_used != -1);
}

void subtilis_arm_regs_used_afterv(subtilis_arm_section_t *arm_s,
				   subtilis_arm_op_t *from,
				   subtilis_arm_op_t *to, size_t int_args,
				   size_t real_args, size_t count,
				   subtilis_regs_used_virt_t *used,
				   subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;
	ud.instr_count = count + 1;

	for (i = SUBTILIS_ARM_INT_VIRT_REG_START; i < int_args; i++) {
		if (prv_is_reg_used_after_to(&ud, i, &ud.int_regs->dist_walker,
					     from, to)) {
			subtilis_bitset_set(&used->int_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	for (i = arm_s->fp_if->max_regs; i < real_args; i++) {
		if (prv_is_reg_used_after_to(&ud, i, &ud.real_regs->dist_walker,
					     from, to)) {
			subtilis_bitset_set(&used->real_regs, i, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
		}
	}

	prv_free_arm_reg_ud(&ud);
}

static bool prv_is_reg_used_after(subtilis_arm_reg_ud_t *ud, size_t reg_num,
				  subtlis_arm_walker_t *dist_walker,
				  subtilis_arm_op_t *from)
{
	subtilis_arm_op_t *to;

	to = &ud->arm_s->op_pool->ops[ud->arm_s->last_op];
	return prv_is_reg_used_after_to(ud, reg_num, dist_walker, from, to);
}

void subtilis_arm_regs_used_after(subtilis_arm_section_t *arm_s,
				  subtilis_arm_op_t *op, size_t int_args,
				  size_t real_args,
				  subtilis_regs_used_t *regs_used,
				  subtilis_error_t *err)
{
	size_t i;
	subtilis_arm_reg_ud_t ud;
	size_t int_reg_list = 0;
	size_t real_reg_list = 0;

	prv_init_arm_reg_ud(&ud, arm_s, err);
	if (err->type != SUBTILIS_ERROR_OK)
		return;

	i = int_args;
	if (i > SUBTILIS_ARM_REG_MAX_ARGS)
		i = SUBTILIS_ARM_REG_MAX_ARGS;
	for (; i <= SUBTILIS_ARM_REG_MAX_INT_REGS - 1; i++) {
		if (prv_is_reg_used_after(&ud, i, &ud.int_regs->dist_walker,
					  op))
			int_reg_list |= 1 << i;
	}

	i = real_args;
	if (i > SUBTILIS_ARM_REG_MAX_ARGS)
		i = SUBTILIS_ARM_REG_MAX_ARGS;
	for (; i < arm_s->fp_if->max_regs; i++) {
		if (prv_is_reg_used_after(&ud, i, &ud.real_regs->dist_walker,
					  op))
			real_reg_list |= 1 << i;
	}

	regs_used->int_regs = int_reg_list;
	regs_used->real_regs = real_reg_list;

	prv_free_arm_reg_ud(&ud);
}

static void prv_update_arg_offsets(subtilis_arm_section_t *arm_s,
				   subtilis_arm_call_site_t *call_site,
				   size_t int_regs_used, size_t real_regs_used,
				   subtilis_error_t *err)
{
	size_t i;
	size_t ptr;
	subtilis_arm_op_t *op;
	subtilis_arm_stran_instr_t *st;
	size_t bytes_saved = 0;

	for (i = 0; i < 15; i++)
		if (1 << i & int_regs_used)
			bytes_saved += sizeof(int32_t);

	if (!arm_s->fp_if) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	for (i = 0; i < arm_s->fp_if->max_regs; i++)
		if (1 << i & real_regs_used)
			bytes_saved += sizeof(double);

	if (call_site->int_args > 4) {
		for (i = 0; i < call_site->int_args - 4; i++) {
			ptr = call_site->int_arg_ops[i];
			op = &arm_s->op_pool->ops[ptr];
			st = &op->op.instr.operands.stran;
			st->offset.op.integer += bytes_saved;
		}
	}

	if (call_site->real_args > 4)
		arm_s->fp_if->update_offs_fn(arm_s, call_site, bytes_saved,
					     err);
}

static void prv_compute_regs_used(subtilis_arm_section_t *arm_s,
				  subtilis_arm_call_site_t *call_site,
				  subtilis_regs_used_t regs_used_before,
				  subtilis_regs_used_t regs_used_after,
				  size_t *int_regs_used, size_t *real_regs_used,
				  subtilis_error_t *err)
{
	subtilis_arm_mtran_instr_t *mtran;
	subtilis_arm_op_t *op;
	size_t real_regs_saved;
	subtilis_arm_br_instr_t *br;

	op = &arm_s->op_pool->ops[call_site->call_site];
	br = &op->op.instr.operands.br;

	op = &arm_s->op_pool->ops[call_site->stm_site];
	mtran = &op->op.instr.operands.mtran;

	*int_regs_used = regs_used_before.int_regs & regs_used_after.int_regs;
	*int_regs_used |= mtran->reg_list;

	if (br->link_type == SUBTILIS_ARM_BR_LINK_INT)
		*int_regs_used &= ~((size_t)1);

	mtran->reg_list = *int_regs_used;
	op = &arm_s->op_pool->ops[call_site->ldm_site];
	mtran = &op->op.instr.operands.mtran;
	mtran->reg_list |= *int_regs_used;

	*real_regs_used = 0;
	if (call_site->ldf_site == INT_MAX)
		return;

	*real_regs_used =
	    regs_used_before.real_regs & regs_used_after.real_regs;

	if (br->link_type == SUBTILIS_ARM_BR_LINK_REAL)
		*real_regs_used &= ~((size_t)1);

	if (!arm_s->fp_if) {
		subtilis_error_set_assertion_failed(err);
		return;
	}

	real_regs_saved = call_site->real_args;
	arm_s->fp_if->update_regs_fn(arm_s, call_site, real_regs_saved,
				     *real_regs_used, err);
}

void subtilis_arm_save_regs(subtilis_arm_section_t *arm_s,
			    subtilis_error_t *err)
{
	size_t i;
	size_t start;
	size_t end;
	size_t int_regs_used;
	size_t real_regs_used;
	subtilis_arm_call_site_t *call_site;
	subtilis_regs_used_t regs_used_before;
	subtilis_regs_used_t regs_used_after;
	subtilis_arm_mtran_instr_t *mtran;
	subtilis_arm_op_t *op;

	for (i = 0; i < arm_s->call_site_count; i++) {
		call_site = &arm_s->call_sites[i];
		start = arm_s->op_pool->ops[call_site->ldm_site].next;
		end = arm_s->op_pool->ops[call_site->stm_site].prev;

		if (start == SIZE_MAX || end == SIZE_MAX) {
			op = &arm_s->op_pool->ops[call_site->stm_site];
			mtran = &op->op.instr.operands.mtran;
			prv_update_arg_offsets(arm_s, call_site,
					       mtran->reg_list, 0, err);
			if (err->type != SUBTILIS_ERROR_OK)
				return;
			continue;
		}

		subtilis_arm_regs_used_before(
		    arm_s, &arm_s->op_pool->ops[end], call_site->int_args,
		    call_site->real_args, &regs_used_before, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		subtilis_arm_regs_used_after(
		    arm_s, &arm_s->op_pool->ops[start], call_site->int_args,
		    call_site->real_args, &regs_used_after, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		prv_compute_regs_used(arm_s, call_site, regs_used_before,
				      regs_used_after, &int_regs_used,
				      &real_regs_used, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;

		prv_update_arg_offsets(arm_s, call_site, int_regs_used,
				       real_regs_used, err);
		if (err->type != SUBTILIS_ERROR_OK)
			return;
	}
}
